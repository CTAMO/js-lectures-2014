#Snake

##Част 1

Реализирайте in-browser версия на играта [Snake](https://en.wikipedia.org/wiki/Snake_%28video_game%29).

###Separation of concerns

Важно е доброто разделяне на графичната и логическа част на задачата. Кодът грижещ се за визуализацията трябва да бъде възможно най-независим от имплементацията на логиката. Комуникацията между двете части на приложението трябва да се случва през добре дефиниран интерфейс на кода грижещ се за логиката. От своя страна логическата реализация на играта трябва да е в пълно неведение за графичната презентация на състоянието на играта и подробностите относно реализацията ѝ.

Такъв тип архитектура позволява по-лесна поддръжка на отделните си компоненти и значително по-проста подмяна на който и да е от тях.

За визуализация може да използвате проста конструкция от DOM обекти(примерно `div`-ове и `span`-ове) с подходящи `class` атрибути за стилизация.

За представяне на игралното поле в кода си използвайте `Array` от `Array` обекти, съдържащи цели числа(или обект предоставящ същия интерфейс):
 * 0 - празно поле, през което може да се преминава
 * 1 - стена, удрянето в която води до край на играта
 * 2 - „плод“, който змията трябва да изяде

За представяне на змията може да използвате `Array` с двойките координати на полетата, които заема. Нужен е и индикатор на посоката, в която се движи (горе, долу, ляво, дясно).

Нужно и следене на резултата на играча, цяло число отбелязващо колко плода е изяла змията.

###Game loop
В повечето процедурни езици игрите имат така наречения game loop, най-често прост `while (true)` цикъл, в чието цяло се извършват всички нужни сметки за един „кадър“ от играта. При край на играта, просто `break`-ваме от `while` цикъла.

Очевидно в случая с javascript такъв класически game loop няма да свърши добра работа. Обърнете внимание на това как ще реализирате game loop-а на играта си, така че да не зависи от блокиращи(и в крайна сметка наработещи) похвати като `while (true)` цикли и все пак да дава добър начин за прекратяване при приключване на играта.

##Част 2

Game логиката да се изнесе в самостоятелно node приложение. Комуникацията между кода за визуализиране и логиката на играта може да запази почти същия интерфейс на извикване на методи, но преноса на данни да не е директно чрез подаване на параметри на методи и получаване на return стойностите им, а чрез съобщения по web socket-и(socket.io също е добър вариант).

##Част 3 (за по-амбициозните и/или опитни)
След като логиката на играта вече е работа изцяло на server-side приложение, а работата на browser-а е само да „рисува“ състоянието на играта, можем да добавим опцията за multiplayer. Единствените нужни промени по кода на сървъра ще бъдат поддръжката на повече от една змия и проверките за колизии между две змии. При добре направен дизайн от самото начало тези добавки могат да станат почти „безплатни“.

##Част 4(за още по-амбициозните и/или опитни)
Много multiplayer игри през един backend.

Има няколко възможни начина за реализация:
 * Един node процес, в който се случва смятането на цялата логика за всички отделни игри
 * Front-facing node процес, който приема връзки от клиентите, и spawn-ва по един node процес за всяка нова игра, след което пренасочва всички връзки за тази игра към съответния процес, който се грижи за нея.

И при двата подхода е нужно да има някакъв вид идентификация на игрите(да речем име на игра). Така клиентите могат да казват към коя игра искат да се включат.

---

##Забележки
Чувствайте се свободни да ползвате всякакви библиотеки, които решите, че могат да са полезни за целта.
